import org.gradle.internal.os.OperatingSystem

import java.text.SimpleDateFormat

description = "Root project of the Commons project of the Gradle Tooling Platform."

group = 'com.gradleware.tooling'
version = getVersion('0.1.0.DEV')

wrapper.gradleVersion = '2.3'

subprojects {

  group = rootProject.group
  version = rootProject.version

  // add required repositories for external dependencies
  repositories {
    jcenter()
    maven {
      name = 'gradle-public-snapshots'
      url gradlePublicSnapshotsRepositoryUrl
    }
  }

  // fail eagerly on version conflict (includes transitive dependencies) and enforce certain dependency versions
  configurations.all {
    resolutionStrategy {
      failOnVersionConflict()

      forcedModules = [
              "org.slf4j:slf4j-api:1.7.7",      // logback-classic uses logback 1.7.6
              "org.hamcrest:hamcrest-core:1.3"  // junit uses hamcrest 1.1
      ]
    }
  }

  // apply Java plugin (production code) and Groovy plugin (test code)
  apply plugin: 'groovy'

  // make sure it compiles and runs with Java 6
  sourceCompatibility = 1.6
  targetCompatibility = 1.6

  // 1) fork the compilation
  // 2) report all compiler warnings
  // 3) on Mac OS, in addition
  //    a) use the correct compiler version (rather than just working with the compatibility flags)
  //    b) convert all compiler warnings to errors
  tasks.withType(AbstractCompile).all {
    options.compilerArgs << '-Xlint:all'
    options.fork = true
    if (OperatingSystem.current().isMacOsX()) {
      options.compilerArgs << '-Werror'
      options.forkOptions.executable = "/usr/libexec/java_home -v $targetCompatibility".execute().text.trim() + "/bin/javac"
    }
  }

  // make sure the main resources folder is always generated in the build directory, otherwise 'compileTestGroovy' issues a warning
  task mainResourcesDir << { sourceSets.main.output.resourcesDir.mkdirs() }
  processResources.dependsOn mainResourcesDir

  // bundle sources
  task sourcesJar(type: Jar) {
    from sourceSets.main.allJava
  }

  // fail for Javadoc errors (there is no way to make it fail on Javadoc warnings)
  javadoc.failOnError = true
  if (JavaVersion.current().isJava8Compatible()) {
    javadoc.options.addStringOption('Xdoclint:none', '-quiet')
  }

  // generate javadoc as part of the build once all tests have passed
  build.dependsOn javadoc
  javadoc.shouldRunAfter check

  // cannot apply publishing plugin to all sub-projects here due to limitations in that plugin
  // apply plugin: 'maven-publish'

  // allow to run tests in parallel
  tasks.withType(Test).all {
      maxParallelForks = 4
  }

  // allow to
  //  - run cross-version tests in 'toolingmodel' sub-project by mapping the relevant system property from the project properties to the forked test process
  //  - run cross-version tests in embedded mode in 'toolingmodel' sub-project by passing the relevant system property from the project properties to the forked test process
  if (path in [':toolingmodel']) {
    tasks.withType(Test).all {
      def propertyKeyVersions = 'com.gradleware.tooling.integtest.versions'
      if (project.properties.containsKey(propertyKeyVersions)) {
        systemProperty propertyKeyVersions, project.properties.get(propertyKeyVersions)
      }
      def propertyKeyEmbedded = 'com.gradleware.tooling.integtest.embedded'
      if (project.properties.containsKey(propertyKeyEmbedded)) {
        systemProperty propertyKeyEmbedded, project.properties.get(propertyKeyEmbedded)
      }
    }
  }

  // apply Checkstyle plugin, mainly to ensure copyright and javadoc is present
  apply plugin: 'checkstyle'

  // share checkstyle config across all sub-projects
  def checkstyleConfigDir = "$rootDir/gradle/config/checkstyle"
  tasks.withType(Checkstyle).all {
    configFile = "$checkstyleConfigDir/checkstyle.xml" as File
    configProperties = ['checkstyleConfigDir': checkstyleConfigDir]
  }

}

def getVersion(def baseVersion) {
  if (project.hasProperty('build.type') && project.property('build.type') == 'release') {
    baseVersion + '.' + new SimpleDateFormat("yyyyMMddkkmmssZ").format(new Date())
  } else {
    baseVersion
  }
}
